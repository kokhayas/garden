package com.zipc.garden.job.tp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.util.EcoreUtil.Copier;

import com.zipc.garden.model.fm.ChildType;
import com.zipc.garden.model.fmcs.FMCSAndExpression;
import com.zipc.garden.model.fmcs.FMCSConstraint;
import com.zipc.garden.model.fmcs.FMCSExpression;
import com.zipc.garden.model.fmcs.FMCSFactory;
import com.zipc.garden.model.fmcs.FMCSImpliesExpression;
import com.zipc.garden.model.fmcs.FMCSMutexExpression;
import com.zipc.garden.model.fmcs.FMCSNotExpression;
import com.zipc.garden.model.fmcs.FMCSODElement;
import com.zipc.garden.model.fmcs.FMCSOrExpression;
import com.zipc.garden.model.fmcs.FMCSRemovesExpression;
import com.zipc.garden.model.fmcs.FMCSRoot;
import com.zipc.garden.model.fmcs.FMCSSelectExpression;
import com.zipc.garden.model.tc.TCFactory;
import com.zipc.garden.model.tc.TCNode;
import com.zipc.garden.model.tc.TCNodeState;
import com.zipc.garden.model.tc.TCRoot;
import com.zipc.garden.webplatform.shared.NodeUtil;

/**
 * A class that manages processing related to flattening.
 */
public class TSDFlatteningLogic {

    /**
     * <pre>
     * Associate the id of the own node with the id of the parent node.
     *  key: id of own node
     *  value: id of the parent node
     * 
     * 自ノードと親ノードのidを対応づける。 key: 自ノードのid, value: 親ノードのid
     * </pre>
     */
    private Map<String, String> parentIdMap = new HashMap<String, String>();

    /**
     * <pre>
     * Associate the id of the own node with the id of the child node.
     *  key: id of own node
     *  value: child node id
     *  
     * 自ノードと子ノードのidを対応づける。 key: 自ノードのid, value: 子ノードのid
     * </pre>
     */
    private Map<String, List<String>> childrenIdMap = new HashMap<String, List<String>>();

    /**
     * <pre>
     * Associate the node id with the TCNode.
     *  key: node id
     *  value: TCNode
     * 
     * ノードのidとtcnodeを対応付ける。 key: ノードのid, value: tcnode
     * </pre>
     */
    private Map<String, TCNode> idToNodeMap = new HashMap<String, TCNode>();

    /**
     * <pre>
     * Associate the node id with the full name.
     *  key: node id
     *  value: node fullname
     *  
     * ノードのidとfullnameを対応づける。 key: ノードのid, value: ノードのfullname
     * </pre>
     */
    private Map<String, String> idToFullnameMap = new HashMap<String, String>();

    /**
     * <pre>
     * Associate the node's full name with id.
     *  key: node fullname
     *  value: node id
     *  
     * ノードのfullnameとidを対応づける。 key: ノードのfullname, value: ノードのid
     * </pre>
     */
    private Map<String, String> fullnameToIdMap = new HashMap<String, String>();

    /**
     * <pre>
     * Leaf node id list
     * 
     * リーフノードのid
     * </pre>
     */
    private List<String> leafList = new ArrayList<String>();

    /**
     * <pre>
     * Temporary area that stores dummy nodes generated by flattening.
     * 
     * フラトニングにより生じるdummyノードを格納するtemporary領域
     * </pre>
     */
    private List<String> addList = new ArrayList<String>();

    /**
     * <pre>
     * A constraint expression that serves as input information for ACTS.
     * 
     * Actsの入力となる制約式
     * </pre>
     */
    private List<String> addNewConstraintList = new ArrayList<String>();

    /**
     * <pre>
     * A logical expression that converts a user-defined constraint expression into a leaf node, AND, OR, and NOT constraint.
     * 
     * ユーザが定義した制約式をリーフノード、AND、ORおよびNOT制約に変換した論理式
     * </pre>
     */
    private List<String> constraintByUsersList = new ArrayList<String>();

    /**
     * <pre>
     * A logical expression that converts the left-hand side (A) of the Implies constraint (A implies B) into leaf nodes, AND, OR, and NOT constraints.
     * 
     * Implies制約(A implies B)の左辺(A)をリーフノード、AND、ORおよびNOT制約に変換した論理式
     * </pre>
     */
    private List<String> leftExpressionList = new ArrayList<String>();

    /**
     * <pre>
     * A logical expression that converts the right-hand side (B) of the Implies constraint (A implies B) into leaf nodes, AND, OR, and NOT constraints.
     * 
     * Implies制約(A implies B)の右辺(B)をリーフノード、AND、ORおよびNOT制約に変換した論理式
     * </pre>
     */
    private List<String> rightExpressionList = new ArrayList<String>();

    /** The syntax used for the ID of the dummy node. */
    public static final String DummyNodeSyntax = "/D_";

    /** Dummy node number. It is increment each time a dummy node is created. */
    private int DummyNodeNumber = 1;

    /** Flattening mode (using ACTS) */
    public static final int MODE_ACTS = 0;

    /** OS-dependent line separator */
    private static final String LINE_SEPARATOR = System.getProperty("line.separator");

    /**
     * Executes the flattening process and returns the result.
     * @param tc TCRoot being edited in Feature pattern generation.
     * @param fmcs The result of conversion from text (fmcRoot) to syntaxTree.
     * @param mode {@link #MODE_ACTS}
     * @return The result of the flattening process.
     */
    public TSDFlatteningResult execute(TCRoot tc, FMCSRoot fmcs, int mode) {

        // Flatteningによりツリー構造を変化させるためコピーしたツリーを使用する
        Copier copier = new EcoreUtil.Copier();
        TCRoot copyTc = (TCRoot) copier.copy(tc);

        // rootnodeを取得する
        TCNode rootnode = copyTc.getActiveRootNode();

        // rootnodeID is "/N/"
        String rootnodeId = "/N/";

        // preprocess for Flattening
        TSDFlatteningResult result = new TSDFlatteningResult();
        if (!preProcessing(rootnodeId, rootnode)) {
            result.setIdMap(idToNodeMap);
            return result;
        }

        // process for Constraints
        if (fmcs != null) {
            extractUserDefinedConstraints(fmcs);
        }
        // main process for Flattening
        deleteNode(rootnodeId);
        // stock result
        if (mode == MODE_ACTS) {
            String actsInfo = makeActsInfo();
            actsInfo = actsInfo.replaceAll("/", "");
            result.setActsinfo(actsInfo);
            Map<String, TCNode> nidToNodeMap = new HashMap<String, TCNode>();
            for (Map.Entry<String, TCNode> e : idToNodeMap.entrySet()) {
                String nkey = (e.getKey()).replaceAll("/", "");
                nidToNodeMap.put(nkey, e.getValue());
            }
            result.setIdMap(nidToNodeMap);
        }

        // CopyしたTCNodeのIDマップを、オリジナルTCNodeのIDマップに変換
        convertIdMap(copier, result);

        return result;
    }

    /**
     * <pre>
     * Get the user-defined constraint expression and store it in {@link #constraintByUsersList}.
     * 
     * ユーザが定義した制約式を取得し、constraintByUsersListに格納する
     * </pre>
     * 
     * @param fmcs Constraint expression (SyntaxTree)
     */
    private void extractUserDefinedConstraints(FMCSRoot fmcs) {
        EList<FMCSConstraint> constraintsList = fmcs.getConstraints();
        for (FMCSConstraint constraint : constraintsList) {
            // ODElement fullname -> id
            List<FMCSODElement> odElementList = TCUtil.getAllContentsOfType(constraint, FMCSODElement.class);
            for (FMCSODElement element : odElementList) {
                String id = fullnameToIdMap.get(element.getFullName());
                element.setFullName(id);
            }
            if (constraint.getExpression() instanceof FMCSRemovesExpression) {
                FMCSRemovesExpression remove1 = (FMCSRemovesExpression) constraint.getExpression();
                // copy RemovesExpression
                FMCSRemovesExpression remove2 = FMCSFactory.eINSTANCE.createFMCSRemovesExpression();
                Copier removeCopier = new EcoreUtil.Copier();
                remove2 = (FMCSRemovesExpression) removeCopier.copy(remove1);
                // renewTreeStructure by dummynode
                String dummy1 = createNewDummynode();
                String dummy2 = createNewDummynode();
                renewTreeStructureByRemoves(remove1.getOdElement().getFullName(), dummy1, dummy2);
                // convert : (left removes right) -> ((NOT(left) OR Dummy) AND (left OR NOT(Dummy))
                // --- (NOT(left) OR Dummy)
                addUserDefinedConstraintsListForRemoveLeft(remove1, dummy2);
                // --- (left OR NOT(Dummy))
                addUserDefinedConstraintsListForRemoveRight(remove2, dummy2);
            } else if (constraint.getExpression() instanceof FMCSImpliesExpression) {
                // convert : (left Implies right) -> (NOT(left) OR right)
                FMCSExpression expression = convertImpliesExpression(constraint.getExpression());
                constraint.setExpression(expression);
                addUserDefinedConstraintsList(constraint);
            } else {
                addUserDefinedConstraintsList(constraint);
            }
        }
    }

    /**
     * <pre>
     * A sub-method that stores user-defined REMOVES constraints in {@link #addUserDefinedConstraintsList}.
     * 
     * ユーザが定義したREMOVES制約をaddUserDefinedConstraintsListに格納するサブメソッド
     * </pre>
     * 
     * @param remove User-defined REMOVES constraints
     * @param dummy Dummy node ID
     */
    private void addUserDefinedConstraintsListForRemoveLeft(FMCSRemovesExpression remove, String dummy) {
        FMCSConstraint constraint = FMCSFactory.eINSTANCE.createFMCSConstraint();
        FMCSExpression left = remove.getExpression();
        FMCSNotExpression not = FMCSFactory.eINSTANCE.createFMCSNotExpression();
        not.setExpression(left);
        FMCSSelectExpression dummySelect = createSelectExpression(dummy);
        FMCSOrExpression or = FMCSFactory.eINSTANCE.createFMCSOrExpression();
        or.getExpressions().add(not);
        or.getExpressions().add(dummySelect);
        constraint.setExpression(or);
        addUserDefinedConstraintsList(constraint);
    }

    /**
     * <pre>
     * A sub-method that stores user-defined REMOVES constraints in {@link #addUserDefinedConstraintsList}.
     * 
     * ユーザが定義したREMOVES制約をaddUserDefinedConstraintsListに格納するサブメソッド
     * </pre>
     * 
     * @param remove User-defined REMOVES constraints
     * @param dummy Dummy node ID
     */
    private void addUserDefinedConstraintsListForRemoveRight(FMCSRemovesExpression remove, String dummy) {
        FMCSConstraint constraint = FMCSFactory.eINSTANCE.createFMCSConstraint();
        FMCSExpression left = remove.getExpression();
        FMCSNotExpression not = FMCSFactory.eINSTANCE.createFMCSNotExpression();
        FMCSSelectExpression dummySelect = createSelectExpression(dummy);
        not.setExpression(dummySelect);
        FMCSOrExpression or = FMCSFactory.eINSTANCE.createFMCSOrExpression();
        or.getExpressions().add(left);
        or.getExpressions().add(not);
        constraint.setExpression(or);
        addUserDefinedConstraintsList(constraint);
    }

    /**
     * Store the user-defined constraint expression in {@link #constraintByUsersList}.
     * @param constraint the user-defined constraint expression
     */
    private void addUserDefinedConstraintsList(FMCSConstraint constraint) {
        notPropagationInitial(constraint);
        notPropagation(constraint.getExpression());
        constraintByUsersList.add(convertConstraintToIdExpression(constraint.getExpression()));
    }

    /**
     * Pre-processing for flattening processing is performed.
     * @param rootNode root node id
     * @param rootTcNode root TCNode
     * @return true: success / false: failure
     */
    private boolean preProcessing(String rootNode, TCNode rootTcNode) {
        // make tree structure with ID
        idToNodeMap.put(rootNode, rootTcNode);
        idToFullnameMap.put(rootNode, NodeUtil.getInstance().getEscapedNodeName(rootTcNode.getName()));
        fullnameToIdMap.put(rootTcNode.getName(), rootNode);
        makeTreeMap(rootNode);
        makeFullnameMap(rootNode);
        // The number of Layer is 3 or more ?
        if (!treeStructureCheck(idToNodeMap.get(rootNode))) {
            // error message
            System.out.println("Error : Depth of tree　must be 3 or more ");
            return false;
        }
        deleteNodeInitial();
        deleteSerialNode(rootNode);
        return true;
    }

    /**
     * <pre>
     * If the local node has one child node, connect the parent node and the child node of the local node and delete the local node.
     * However, if the local node is the parent node of the terminal node, it is not deleted.
     * 
     * 自ノードの子ノードが1つの場合、自ノードの親ノードと子ノードを繋ぎ、自ノードを削除する。
     * 但し、自ノードが末端ノードの親ノードの場合は削除しない。
     * </pre>
     * 
     * @param rootNode root node
     */
    private void deleteSerialNode(String rootNode) {
        for (String leaf : leafList) {
            String self = leaf;
            String leafParent = parentIdMap.get(self);
            String parent = leafParent;

            while (!parentIdMap.get(parent).equals(rootNode)) {
                TCNode parentTcNode = idToNodeMap.get(parent);

                // 自ノードが末端ノードの親ノードでない かつ 自ノードの子ノードが１つの場合
                if (!parent.equals(leafParent) && parentTcNode.getChildren().size() == 1) {
                    String grandParent = parentIdMap.get(parent);
                    TCNode grandParentTcNode = idToNodeMap.get(grandParent);

                    if (self.equals(leaf) && grandParentTcNode.getChildren().size() == 1) {
                        grandParentTcNode.setChildType(ChildType.XOR);
                    }

                    deleteNodeWithRenewConnectRelationship(parent);
                    parentTcNode.setState(TCNodeState.DELETED);

                    // next
                    parent = grandParent;
                } else {
                    // next
                    self = parent;
                    parent = parentIdMap.get(parent);
                }
            }
        }
    }

    /**
     * <pre>
     * Constraint expressions starting with NOT are expanded according to De Morgan's laws.
     * 
     * NOTから始まる制約式を、ドモルガンの法則に従って展開する
     * </pre>
     * 
     * @param constraint Constraint expression
     */
    private void notPropagationInitial(FMCSConstraint constraint) {

        FMCSExpression element = constraint.getExpression();

        while (element instanceof FMCSNotExpression) {
            FMCSExpression next = ((FMCSNotExpression) element).getExpression();
            if (next instanceof FMCSAndExpression) {
                constraint.setExpression(convertNotAndExpression((FMCSAndExpression) next));
            }
            if (next instanceof FMCSOrExpression) {
                constraint.setExpression(convertNotOrExpression((FMCSOrExpression) next));
            }
            if (next instanceof FMCSNotExpression) {
                FMCSExpression nn = ((FMCSNotExpression) next).getExpression();
                constraint.setExpression(nn);
            }
            if (next instanceof FMCSMutexExpression) {
                constraint.setExpression(convertNotMutexExpression((FMCSMutexExpression) next));
            }
            if (next instanceof FMCSSelectExpression) {
                break;
            }
            element = constraint.getExpression();
        }
    }

    /**
     * <pre>
     * Constraint expressions that do not start with NOT are expanded according to De Morgan's laws.
     * 
     * NOTから始まらない制約式を、ドモルガンの法則に従って展開する
     * </pre>
     * 
     * @param current Constraint expression
     */
    private void notPropagation(FMCSExpression current) {

        if (current instanceof FMCSSelectExpression || current instanceof FMCSMutexExpression) {
            return;
        }
        if (current instanceof FMCSAndExpression) {
            EList<FMCSExpression> eList = ((FMCSAndExpression) current).getExpressions();
            for (int i = 0; i < eList.size(); ++i) {
                FMCSExpression next = eList.get(i);
                if (next instanceof FMCSSelectExpression) {
                    continue;
                }
                if (next instanceof FMCSMutexExpression) {
                    eList.set(i, convertMutexExpression((FMCSMutexExpression) next));
                    continue;
                }
                if (next instanceof FMCSAndExpression || next instanceof FMCSOrExpression) {
                    notPropagation(next);
                }
                if (next instanceof FMCSNotExpression) {
                    FMCSExpression nn = ((FMCSNotExpression) next).getExpression();
                    if (nn instanceof FMCSSelectExpression) {
                        continue;
                    }
                    if (nn instanceof FMCSMutexExpression) {
                        eList.set(i, convertNotMutexExpression((FMCSMutexExpression) nn));
                        continue;
                    }
                    if (nn instanceof FMCSAndExpression) {
                        eList.set(i, convertNotAndExpression((FMCSAndExpression) nn));
                        notPropagation(eList.get(i));
                    }
                    if (nn instanceof FMCSOrExpression) {
                        eList.set(i, convertNotOrExpression((FMCSOrExpression) nn));
                        notPropagation(eList.get(i));
                    }
                    if (nn instanceof FMCSNotExpression) {
                        FMCSExpression nnn = ((FMCSNotExpression) nn).getExpression();
                        eList.set(i, nnn);
                        notPropagation(eList.get(i));
                    }
                }
            }
        }
        if (current instanceof FMCSOrExpression) {
            EList<FMCSExpression> eList = ((FMCSOrExpression) current).getExpressions();

            for (int i = 0; i < eList.size(); ++i) {
                FMCSExpression next = eList.get(i);
                if (next instanceof FMCSSelectExpression) {
                    continue;
                }
                if (next instanceof FMCSMutexExpression) {
                    eList.set(i, convertMutexExpression((FMCSMutexExpression) next));
                    continue;
                }
                if (next instanceof FMCSAndExpression || next instanceof FMCSOrExpression) {
                    notPropagation(next);
                }
                if (next instanceof FMCSNotExpression) {
                    FMCSExpression nn = ((FMCSNotExpression) next).getExpression();
                    if (nn instanceof FMCSSelectExpression) {
                        continue;
                    }
                    if (nn instanceof FMCSMutexExpression) {
                        eList.set(i, convertNotMutexExpression((FMCSMutexExpression) nn));
                        continue;
                    }
                    if (nn instanceof FMCSAndExpression) {
                        eList.set(i, convertNotAndExpression((FMCSAndExpression) nn));
                        notPropagation(eList.get(i));
                    }
                    if (nn instanceof FMCSOrExpression) {
                        eList.set(i, convertNotOrExpression((FMCSOrExpression) nn));
                        notPropagation(eList.get(i));
                    }
                    if (nn instanceof FMCSNotExpression) {
                        FMCSExpression nnn = ((FMCSNotExpression) nn).getExpression();
                        eList.set(i, nnn);
                        notPropagation(eList.get(i));
                    }
                }
            }
        }
    }

    /**
     * <pre>
     * Convert Implies constraint (A implies B) to NOT and OR constraint representations (NOT (A) OR B).
     * 
     * Implies制約（A implies B）をNOT制約およびOR制約の表現（NOT(A) OR B）に変換する
     * </pre>
     * 
     * @param implies Implies constraint
     * @return Logical formula after conversion
     */
    private FMCSExpression convertImpliesExpression(FMCSExpression implies) {
        if (implies instanceof FMCSImpliesExpression) {
            FMCSExpression left = ((FMCSImpliesExpression) implies).getLeftExpression();
            FMCSExpression right = ((FMCSImpliesExpression) implies).getRightExpression();
            FMCSOrExpression or = FMCSFactory.eINSTANCE.createFMCSOrExpression();
            FMCSNotExpression not = FMCSFactory.eINSTANCE.createFMCSNotExpression();
            not.setExpression(left);
            or.getExpressions().add(not);
            or.getExpressions().add(right);
            return or;
        }
        return implies;
    }

    /**
     * <pre>
     * Convert NOT and AND constraints (NOT (A AND B AND ...)) to representations of NOT and OR constraints (NOT (A) OR NOT (B) OR ...) according to De Morgan's laws
     * 
     * NOTおよびAND制約（NOT(A AND B AND ...)）をドモルガンの法則に従ってNOTおよびOR制約の表現（NOT(A) OR NOT(B) OR ...）に変換する
     * </pre>
     * 
     * @param and AND constraint
     * @return Logical formula after conversion
     */
    private FMCSExpression convertNotAndExpression(FMCSAndExpression and) {
        EList<FMCSExpression> eList = and.getExpressions();
        FMCSOrExpression or = FMCSFactory.eINSTANCE.createFMCSOrExpression();
        while (!eList.isEmpty()) {
            FMCSNotExpression not = FMCSFactory.eINSTANCE.createFMCSNotExpression();
            not.setExpression(eList.get(0));
            or.getExpressions().add(not);
        }
        return or;
    }

    /**
     * <pre>
     * Converts NOT and OR constraints (NOT (A OR B OR ...)) to representations of NOT and AND constraints (NOT (A) AND NOT (B) AND ...) according to De Morgan's laws
     * 
     * NOTおよびOR制約（NOT(A OR B OR ...)）をドモルガンの法則に従ってNOTおよびAND制約の表現（NOT(A) AND NOT(B) AND ...)）に変換する
     * </pre>
     * 
     * @param or OR constraint
     * @return Logical formula after conversion
     */
    private FMCSExpression convertNotOrExpression(FMCSOrExpression or) {
        EList<FMCSExpression> eList = or.getExpressions();
        FMCSAndExpression and = FMCSFactory.eINSTANCE.createFMCSAndExpression();
        while (!eList.isEmpty()) {
            FMCSNotExpression not = FMCSFactory.eINSTANCE.createFMCSNotExpression();
            not.setExpression(eList.get(0));
            and.getExpressions().add(not);
        }
        return and;
    }

    /**
     * <pre>
     * Convert NOT-MUTEX constraints to representations of AND and OR constraints
     * 
     * NOT-MUTEX制約（NOT(MUTEX(A,B,C,...))）をAND,OR制約の表現（(A AND B) OR (A AND C) OR (B AND C) OR... (AllCombination)）に変換する
     * </pre>
     * 
     * @param mutex MUTEX constraints
     * @return Logical formula after conversion
     */
    private FMCSExpression convertNotMutexExpression(FMCSMutexExpression mutex) {
        EList<FMCSODElement> elementList = mutex.getOdElements();
        List<String> idList = new ArrayList<String>();
        for (FMCSODElement element : elementList) {
            idList.add(element.getFullName());
        }
        if (idList.size() == 2) {
            FMCSAndExpression and = makeAndForNotMutex(idList.get(0), idList.get(1));
            return and;
        } else {
            FMCSOrExpression or = FMCSFactory.eINSTANCE.createFMCSOrExpression();
            for (int j = 0; j < idList.size(); ++j) {
                for (int k = j + 1; k < idList.size(); ++k) {
                    or.getExpressions().add(makeAndForNotMutex(idList.get(j), idList.get(k)));
                }
            }
            return or;
        }
    }

    /**
     * <pre>
     * Convert MUTEX constraints to NOT, OR, AND representations
     * 
     * MUTEX制約（Mutex(A,B,C,...)）をNOT,OR,ANDの表現（(NOT(A)OR NOT(B)) AND (NOT(A) OR NOT(C)) AND (NOT(B) OR NOT(C)) AND ... (ALL Combination)）に変換する
     * </pre>
     * 
     * @param mutex MUTEX constraints
     * @return Logical formula after conversion
     */
    private FMCSExpression convertMutexExpression(FMCSMutexExpression mutex) {
        EList<FMCSODElement> elementList = mutex.getOdElements();
        List<String> idList = new ArrayList<String>();
        for (FMCSODElement element : elementList) {
            idList.add(element.getFullName());
        }
        if (idList.size() == 2) {
            FMCSOrExpression or = makeOrForMutex(idList.get(0), idList.get(1));
            return or;
        } else {
            FMCSAndExpression and = FMCSFactory.eINSTANCE.createFMCSAndExpression();
            for (int j = 0; j < idList.size(); ++j) {
                for (int k = j + 1; k < idList.size(); ++k) {
                    and.getExpressions().add(makeOrForMutex(idList.get(j), idList.get(k)));
                }
            }
            return and;
        }
    }

    /**
     * <pre>
     * A submethod for deployment MUTEX constraints to OR and NOT constraints.
     * 
     * MUTEX制約をORおよびNOT制約に展開するためのサブメソッド
     * </pre>
     * 
     * @param str1 FullName to set for ODElement
     * @param str2 FullName to set for ODElement
     * @return Logical formula after conversion
     */
    private FMCSOrExpression makeOrForMutex(String str1, String str2) {
        FMCSOrExpression or = FMCSFactory.eINSTANCE.createFMCSOrExpression();
        FMCSNotExpression not1 = createNotExpression(str1);
        FMCSNotExpression not2 = createNotExpression(str2);
        or.getExpressions().add(not1);
        or.getExpressions().add(not2);
        return or;
    }

    /**
     * <pre>
     * A submethod for deployment MUTEX constraints to AND and NOT constraints.
     * 
     * MUTEX制約をANDおよびNOT制約に展開するためのサブメソッド
     * </pre>
     * 
     * @param str1 FullName to set for ODElement
     * @param str2 FullName to set for ODElement
     * @return Logical formula after conversion
     */
    private FMCSAndExpression makeAndForNotMutex(String str1, String str2) {
        FMCSAndExpression and = FMCSFactory.eINSTANCE.createFMCSAndExpression();
        FMCSSelectExpression select1 = createSelectExpression(str1);
        FMCSSelectExpression select2 = createSelectExpression(str2);
        and.getExpressions().add(select1);
        and.getExpressions().add(select2);
        return and;
    }

    /**
     * <pre>
     * Create a new FMCSSelectExpression and set fullname to ODElement.
     * 
     * FMCSSelectExpressionを新たに作成およびodElementにfullnameをセットする
     * </pre>
     * 
     * @param fullname The full name to set for odElement.
     * @return
     */
    private FMCSSelectExpression createSelectExpression(String fullname) {
        FMCSSelectExpression select = FMCSFactory.eINSTANCE.createFMCSSelectExpression();
        FMCSODElement element = FMCSFactory.eINSTANCE.createFMCSODElement();
        element.setFullName(fullname);
        select.setOdElement(element);
        return select;
    }

    /**
     * <pre>
     * Create a new FMCSNotExpression and set fullname to ODElement.
     * 
     * FMCSNotExpressionを新たに作成およびodElementにfullnameをセットする
     * </pre>
     * 
     * @param fullname The full name to set for odElement.
     * @return
     */
    private FMCSNotExpression createNotExpression(String fullname) {
        FMCSNotExpression not = FMCSFactory.eINSTANCE.createFMCSNotExpression();
        FMCSSelectExpression select = FMCSFactory.eINSTANCE.createFMCSSelectExpression();
        FMCSODElement element = FMCSFactory.eINSTANCE.createFMCSODElement();
        element.setFullName(fullname);
        select.setOdElement(element);
        not.setExpression(select);
        return not;
    }

    /**
     * <pre>
     * For the parent-child relationship of Node corresponding to the right side of the REMOVES constraint, transform the tree structure using two dummyNodes.
     * 
     * REMOVES制約の右辺に相当するNodeの親子関係について、2つのdummyNodeを用いて木構造を変換する
     * </pre>
     * 
     * @param self Node corresponding to the right side of the REMOVES constraint. <br>
     *            After modification, it becomes a child node of dummy1.<br>
     *            REMOVES制約の右辺に相当するNode. 修正後はdummy1の子ノードになる.
     * @param dummy1 DummyNode to add between self and the parent node of self. <br>
     *            dummy1 has an XOR relationship with the child node. <br>
     *            selfとselfの親ノード間に追加するdummyNode. dummy1は子ノードとXORの関係になる.
     * @param dummy2 This dummyNode is newly added as a child node of dummy1.<br>
     *            dummy1の子ノードとして新規追加するdummyNode.
     */
    private void renewTreeStructureByRemoves(String self, String dummy1, String dummy2) {
        String parent = parentIdMap.get(self);

        // remove parent-child relation between parent and self
        deleteRelationshipWithCurrentParentnode(self);

        // create parent-child relation between parent and dummy1
        addRelationshipWithNewParentnode(dummy1, parent);

        // create parent-child relation between dummy1 and self
        // create parent-child relation between dummy1 and dummy2
        idToNodeMap.get(dummy1).setChildType(ChildType.XOR);
        addRelationshipWithNewParentnode(self, dummy1);
        addRelationshipWithNewParentnode(dummy2, dummy1);
        leafList.add(dummy2);
    }

    /**
     * Gets the sibling node of the specified node.
     * @param self specified node.
     * @return Sibling node
     */
    private List<String> getBrothers(String self) {
        String parent = parentIdMap.get(self);
        List<String> children = childrenIdMap.get(parent);
        List<String> brothers = new ArrayList<String>();
        for (String child : children) {
            if (child != self) {
                brothers.add(child);
            }
        }
        return brothers;
    }

    /**
     * Gets the type of the specified node.
     * @param node specified node.
     * @return AND or OR
     */
    private String getSyntax(TCNode node) {
        if (node.getChildType() == ChildType.AND) {
            return " AND ";
        } else {
            return " OR ";
        }
    }

    /**
     * <pre>
     * Expand a node with NOT constraint to a leaf node and convert it to a logical expression with all relationships ANDed.
     * 
     * NOT制約が付与されたノードをリーフノードに展開し、全ての関係をANDとする論理式に変換する
     * </pre>
     * 
     * @param self Node ID
     * @return Leaf node,! And AND-only formulas <br>
     *         リーフノード、!およびANDのみの論理式
     */
    private String convertNodeToLeafWithOnlyAndExpression(String self) {

        List<String> childList = childrenIdMap.get(self);
        if (childList == null || childList.isEmpty()) {
            return "!" + self;
        }
        StringBuilder formula = new StringBuilder("(");
        for (int i = 0; i < childList.size(); ++i) {
            if (i == childList.size() - 1) {
                formula.append(convertNodeToLeafWithOnlyAndExpression(childList.get(i)));
            } else {
                formula.append(convertNodeToLeafWithOnlyAndExpression(childList.get(i))).append(" AND ");
            }
        }
        formula.append(")");

        return formula.toString();
    }

    /**
     * <pre>
     * Convert to a logical expression with only AND and OR constraints and IDs
     * 
     * AND制約およびOR制約とIDのみの論理式に変換する
     * </pre>
     * 
     * @param expression
     * @return Logical expression with only AND, OR, ID
     */
    private String convertConstraintToIdExpression(FMCSExpression expression) {

        String formula = "";

        // SELECT
        if (expression instanceof FMCSSelectExpression) {
            FMCSSelectExpression select = (FMCSSelectExpression) expression;
            formula = select.getOdElement().getFullName();
            formula = convertNodeToLiefLogicalExpression(formula);
        }
        // MUTEX
        if (expression instanceof FMCSMutexExpression) {
            FMCSMutexExpression mutex = (FMCSMutexExpression) expression;
            EList<FMCSODElement> odList = mutex.getOdElements();

            if (odList.size() == 2) {
                formula += "(" + convertNodeToLeafWithOnlyAndExpression(odList.get(0).getFullName()) + " OR " + convertNodeToLeafWithOnlyAndExpression(odList.get(1).getFullName())
                        + ")";
            } else {
                formula += "(";
                for (int i = 0; i < odList.size(); ++i) {
                    for (int j = i + 1; j < odList.size(); ++j) {
                        String comb = "(" + convertNodeToLeafWithOnlyAndExpression(odList.get(i).getFullName()) + " OR "
                                + convertNodeToLeafWithOnlyAndExpression(odList.get(j).getFullName()) + ")";
                        if ((i == odList.size() - 2) && j == (odList.size() - 1)) {
                            formula += comb;
                        } else {
                            formula += comb + " AND ";
                        }
                    }
                }
                formula += ")";
            }
        }
        // NOT
        if (expression instanceof FMCSNotExpression) {
            FMCSNotExpression not = (FMCSNotExpression) expression;
            FMCSSelectExpression select = (FMCSSelectExpression) not.getExpression();
            formula = convertNodeToLeafWithOnlyAndExpression(select.getOdElement().getFullName());
        }
        // AND
        if (expression instanceof FMCSAndExpression) {
            FMCSAndExpression and = (FMCSAndExpression) expression;
            EList<FMCSExpression> andList = and.getExpressions();
            formula += "(";
            for (int i = 0; i < andList.size(); ++i) {
                if (i == andList.size() - 1) {
                    formula += convertConstraintToIdExpression(andList.get(i));
                } else {
                    formula += convertConstraintToIdExpression(andList.get(i)) + " AND ";
                }
            }
            formula += ")";
        }
        // OR
        if (expression instanceof FMCSOrExpression) {
            FMCSOrExpression or = (FMCSOrExpression) expression;
            EList<FMCSExpression> orList = or.getExpressions();
            formula += "(";
            for (int i = 0; i < orList.size(); ++i) {
                if (i == orList.size() - 1) {
                    formula += convertConstraintToIdExpression(orList.get(i));
                } else {
                    formula += convertConstraintToIdExpression(orList.get(i)) + " OR ";
                }
            }
            formula += ")";
        }
        return formula;
    }

    /**
     * <pre>
     * Convert the node stored in the list to a logical expression with only leaf node and AND, OR.
     * 
     * リストに格納されたノードをリーフノードとAND,ORのみの論理式に変換する
     * </pre>
     * 
     * @param list Node ID list.
     * @param syntax Either AND or OR
     * @return Logical expression only for leaf node and AND, OR
     */
    private String convertNodeToLiefLogicalExpression(List<String> list, String syntax) {
        if (list == null || list.isEmpty()) {
            return null;
        }
        if (list.size() == 1) {
            if (childrenIdMap.get(list.get(0)) == null || childrenIdMap.get(list.get(0)).isEmpty()) {
                return list.get(0);
            } else {
                return convertNodeToLiefLogicalExpression(list.get(0));
            }
        }
        StringBuilder formula = new StringBuilder("(");
        for (int i = 0; i < list.size(); ++i) {
            if (i != (list.size() - 1)) {
                formula.append(convertNodeToLiefLogicalExpression(list.get(i))).append(syntax);
            } else {
                formula.append(convertNodeToLiefLogicalExpression(list.get(i)));
            }
        }
        formula.append(")");

        return formula.toString();
    }

    /**
     * <pre>
     * Convert a node to a logical expression containing only leaf nodes and AND and OR.
     * 
     * ノードをリーフノードとAND,ORのみの論理式に変換する
     * </pre>
     * 
     * @param self node
     * @return Logical expression only for leaf node and AND, OR
     */
    private String convertNodeToLiefLogicalExpression(String self) {
        List<String> childList = childrenIdMap.get(self);
        if (childList == null || childList.isEmpty()) {
            return self;
        }
        String syntax = getSyntax(idToNodeMap.get(self));
        StringBuilder formula = new StringBuilder("(");
        for (int i = 0; i < childList.size(); ++i) {
            if (i != (childList.size() - 1)) {
                formula.append(convertNodeToLiefLogicalExpression(childList.get(i))).append(syntax);
            } else {
                formula.append(convertNodeToLiefLogicalExpression(childList.get(i)));
            }
        }
        formula.append(")");
        return formula.toString();
    }

    /**
     * Recursively searches for child nodes of the specified node and creates {@link #idToNodeMap} and {@link #fullnameToIdMap}.
     * @param self Self node id
     */
    private void makeFullnameMap(String self) {
        TCNode selfTcNode = idToNodeMap.get(self);
        if (selfTcNode.getChildren().isEmpty()) {
            return;
        }
        List<String> childList = childrenIdMap.get(self);
        for (String child : childList) {
            String fullname = idToFullnameMap.get(self) + "." + NodeUtil.getInstance().getEscapedNodeName((idToNodeMap.get(child)).getName());
            idToFullnameMap.put(child, fullname);
            fullnameToIdMap.put(fullname, child);
            makeFullnameMap(child);
        }
    }

    /**
     * <pre>
     * The main processing of flattening.
     * When the following conditions are met, delete Node to make the layer thinner.
     * Flattening本処理
     * 以下の条件を満たすときNodeを削除して層を薄くしていく
     * 
     *  ・leaf and Node is connected by AND, Node and Node of Parent is connected by AND
     *  ・leaf and Node is connected by XOR, Node and Node of Parent is connected by XOR
     * </pre>
     * 
     * @param rootId Root node Id
     */
    private void deleteNode(String rootId) {

        // flatteningの完了チェック
        // complete = true: 完了、 false：未完了
        // Number of Layer is just 3 (root - parameter - leaf)
        boolean complete = false;
        while (!complete) {

            for (String lid : leafList) {

                TCNode lf = idToNodeMap.get(lid);
                if (lf.getState() == TCNodeState.DELETED) {
                    continue;
                } else {

                    String sid = lid;
                    String pid = parentIdMap.get(sid);
                    String gpid = parentIdMap.get(pid);

                    // leafが3段目にくるまで
                    while (!rootId.equals(pid) && !rootId.equals(sid)) {

                        TCNode pt = idToNodeMap.get(pid);
                        TCNode gpt = idToNodeMap.get(gpid);
                        if (pt.getChildType() == gpt.getChildType()) { // AND-AND、XOR-XORの関係の場合

                            // delete parent node
                            // new parent is grandparent
                            deleteNodeWithRenewConnectRelationship(pid);

                            // next
                            pid = parentIdMap.get(sid);
                            gpid = parentIdMap.get(pid);

                            if (rootId.equals(gpid) || rootId.equals(pid)) {
                                break;
                            }

                        } else if (!rootId.equals(gpid)) {

                            String ggpid = parentIdMap.get(gpid);
                            TCNode ggpt = idToNodeMap.get(ggpid);
                            if ((pt.getChildType() == ChildType.XOR) && (gpt.getChildType() == ChildType.AND) && (ggpt.getChildType() == ChildType.XOR)) {

                                while (childrenIdMap.get(gpid).size() >= 2) {
                                    String bn = childrenIdMap.get(gpid).get(0); // 先頭のノードをliftするNodeとする
                                    String ls = childrenIdMap.get(gpid).get(childrenIdMap.get(gpid).size() - 1);// 最終ノードを最後まで残す

                                    String did = liftNode(bn, rootId); // did : 新規生成されたダミーノードのID
                                    // （リフトしたノードの子ノード） Implies gpid の論理式
                                    leftExpressionList.add(convertNodeToLiefLogicalExpression(ls));
                                    rightExpressionList.add(convertNodeToLiefLogicalExpression(bn));

                                    // dummyNodeをリフトしたノードの子に追加
                                    addRelationshipWithNewParentnode(did, bn);
                                    addList.add(did);

                                    // DummyNode Implies （gpidの兄弟） の論理式
                                    List<String> brothers = getBrothers(gpid); // brothers : gpidの兄弟ノード
                                    String syntax = getSyntax(ggpt);
                                    leftExpressionList.add(convertNodeToLiefLogicalExpression(brothers, syntax));
                                    rightExpressionList.add(did);
                                }
                                // 残った１つを潰す
                                gpt.setChildType(pt.getChildType());
                                deleteNodeWithRenewConnectRelationship(childrenIdMap.get(gpid).get(0));

                                break;
                            } else {
                                // next step
                                sid = parentIdMap.get(sid);
                                pid = parentIdMap.get(sid);
                                gpid = parentIdMap.get(pid);
                            }
                        } else {
                            // next step
                            sid = parentIdMap.get(sid);
                            pid = parentIdMap.get(sid);
                            gpid = parentIdMap.get(pid);
                        }
                    }
                }
            }

            // flatteningの完了チェック
            // complete = true: 完了、 false：未完了
            for (String s : addList) {
                leafList.add(s);
            }
            addList.clear();

            complete = true;
            for (String lid : leafList) {
                String pid = parentIdMap.get(lid);
                if (rootId.equals(parentIdMap.get(pid))) {
                    continue;
                } else {
                    complete = false;
                    break;
                }
            }
        }
    }

    /**
     * <pre>
     * It is checked whether the specified node is more than Three-layer.
     * 
     * tree structureが3層以上あるかチェック
     * </pre>
     * 
     * @param rootNode Specified node
     * @return true: 3 layers or more, false: less than 3 layers<br>
     *         true : 3層以上ある , false : 3層未満である
     */
    private boolean treeStructureCheck(TCNode rootNode) {
        EList<TCNode> children = rootNode.getChildren();
        if (children.isEmpty()) {
            return false;
        }
        for (TCNode child : children) {
            EList<TCNode> grandChildren = child.getChildren();
            if (grandChildren.isEmpty()) {
                return false;
            }
        }
        return true;
    }

    /**
     * <pre>
     * Recursively search for child nodes from the specified node and create {@link #leafList}, {@link #parentIdMap}, {@link #idToNodeMap}, {@link #childrenIdMap}.
     * 
     * tree structureをIDのみで表現する
     * </pre>
     * 
     * @param self specified node id
     */
    private void makeTreeMap(String self) {
        TCNode selfTcNode = idToNodeMap.get(self);
        if (selfTcNode.getChildren().isEmpty()) {
            leafList.add(self);
            return;
        }
        EList<TCNode> children = selfTcNode.getChildren();
        List<String> childrenList = new ArrayList<String>();
        for (int i = 0; i < selfTcNode.getChildren().size(); ++i) {
            String newId = self.substring(0, self.length() - 1);
            String child = newId + "_" + Integer.toString(i + 1) + "/";
            childrenList.add(child);
            parentIdMap.put(child, self);
            idToNodeMap.put(child, children.get(i));
            makeTreeMap(child);
        }
        childrenIdMap.put(self, childrenList);
    }

    /**
     * <pre>
     * Delete the self node and newly connect the parent node and the child node.
     * 
     * 自ノードを削除して親ノードと子ノードを新たに接続する
     * </pre>
     * 
     * @param self self node id
     */
    private void deleteNodeWithRenewConnectRelationship(String self) {
        String parent = parentIdMap.get(self);
        List<String> childrenOfSelfList = childrenIdMap.get(self);
        deleteRelationshipWithCurrentParentnode(self);
        for (String child : childrenOfSelfList) {
            addRelationshipWithNewParentnode(child, parent);
        }
        idToNodeMap.get(self).setState(TCNodeState.DELETED);
    }

    /**
     * <pre>
     * If the leaf node and the parent node are connected in an AND relationship, delete the leaf node and make the parent node a new leaf node.
     * 
     * リーフノードと自ノードがANDの関連で接続している場合、リーフノードを削除して、自ノードを新しいリーフノードとする
     * </pre>
     */
    private void deleteNodeInitial() {

        List<String> deleteList = new ArrayList<String>();
        List<String> addList = new ArrayList<String>();

        for (String leaf : leafList) {
            TCNode parentTcNode = idToNodeMap.get(parentIdMap.get(leaf));
            if (parentTcNode.getChildType() == ChildType.AND) {

                // Warning Message
                System.out.println("Warning: リーフノードがANDで接続されています");
                System.out.println("Warning: " + idToNodeMap.get(leaf).getName() + "を削除します");

                // stock delete leaf and new leaf(parent)
                deleteList.add(leaf);
                if (!addList.contains(parentIdMap.get(leaf))) {
                    addList.add(parentIdMap.get(leaf));
                }

                // renew Structure of Tree
                idToNodeMap.get(leaf).setState(TCNodeState.DELETED);
                deleteRelationshipWithCurrentParentnode(leaf);
            }
        }

        // renew leafList
        for (String id : addList) {
            leafList.add(id);
        }
        for (String id : deleteList) {
            leafList.remove(leafList.indexOf(id));
        }
    }

    /**
     * <pre>
     * Delete the relationship between the self node and the parent node.
     * 
     * 自ノードと親ノードとの関係を削除する
     * </pre>
     * 
     * @param self Self node ID
     */
    private void deleteRelationshipWithCurrentParentnode(String self) {
        TCNode selfTcNode = idToNodeMap.get(self);
        String parent = parentIdMap.get(self);
        TCNode parentTcNodenode = idToNodeMap.get(parent);
        parentTcNodenode.getChildren().remove(selfTcNode);
        parentIdMap.remove(self);
        childrenIdMap.get(parent).remove(self);
    }

    /**
     * <pre>
     * Establish a new relationship as the parent node of the self node.
     * 
     * 自ノードの親ノードとして新たに関係を結ぶ
     * </pre>
     * 
     * @param self Self node ID
     * @param parent Parent node ID
     */
    private void addRelationshipWithNewParentnode(String self, String parent) {
        TCNode selfTcNode = idToNodeMap.get(self);
        TCNode parentTcNode = idToNodeMap.get(parent);
        (parentTcNode.getChildren()).add(selfTcNode);
        (childrenIdMap.get(parent)).add(self);
        parentIdMap.put(self, parent);
    }

    /**
     * Create a new dummy node.
     * @return The ID of the created dummy node.
     */
    private String createNewDummynode() {
        TCNode newNode = TCFactory.eINSTANCE.createTCNode();
        String name = "dummy" + Integer.toString(DummyNodeNumber);
        newNode.setName(name);
        newNode.setState(TCNodeState.NEW);

        String dummy = DummyNodeSyntax + Integer.toString(DummyNodeNumber++) + "/";
        idToNodeMap.put(dummy, newNode);
        idToFullnameMap.put(dummy, name);
        fullnameToIdMap.put(name, dummy);
        List<String> children = new ArrayList<String>();
        childrenIdMap.put(dummy, children);

        return dummy;
    }

    /**
     * <pre>
     * Convert "value" to the expression "parameter = value".
     * 
     * Actsのインプット向けに value を parameter = value の式に変換する
     * </pre>
     * 
     * @param value Leaf node ID
     * @return Converted expression
     */
    private String convertFormulaForActs(String value) {
        return parentIdMap.get(value) + " = " + "\"" + value + "\"";
    }

    /**
     * <pre>
     * Convert "value" to the expression "parameter != value".
     * 
     * Actsのインプット向けに value を parameter != value の式に変換する
     * </pre>
     * 
     * @param value
     * @return Converted expression
     */
    private String convertFormulaNotForActs(String value) {
        return parentIdMap.get(value) + " != " + "\"" + value + "\"";
    }

    /**
     * <pre>
     * Connect node to Root node
     * 
     * nodeをRootnodeに接続する
     * </pre>
     * 
     * @param node ID of the node that connects to the Root node
     * @param rootNode ID of root node
     * @return ID of dummyNode
     */
    private String liftNode(String node, String rootNode) {
        deleteRelationshipWithCurrentParentnode(node);
        addRelationshipWithNewParentnode(node, rootNode);
        String dummyNode = createNewDummynode();
        return dummyNode;
    }

    /**
     * <pre>
     * Store the constraint expression that is the input of ACTS in {@link #addNewConstraintList}.
     * 
     * modeに従いacts／pict用のインプットとなる制約式をaddNewConstraintListに格納する
     * </pre>
     * 
     * @param mode ACTS mode
     */
    private void makeConstraintList(int mode) {

        // Flatteningにより生じた制約の処理
        if (!leftExpressionList.isEmpty()) {
            for (int i = 0; i < leftExpressionList.size(); ++i) {
                String left = leftExpressionList.get(i);
                String right = rightExpressionList.get(i);

                if (mode == MODE_ACTS) {
                    for (String leaf : leafList) {
                        left = replaceFormula(left, leaf);
                        right = replaceFormula(right, leaf);
                    }
                    addNewConstraintList.add(left + " => " + right);
                }
            }
        }

        // User定義による制約の処理
        if (!constraintByUsersList.isEmpty()) {
            for (String formula : constraintByUsersList) {
                if (mode == MODE_ACTS) {
                    for (String leaf : leafList) {
                        formula = replaceFormula(formula, leaf);
                    }
                    addNewConstraintList.add(formula);
                }
            }
        }
    }

    /**
     * Create the input information for ACTS.
     * @return ACTS input information.
     */
    private String makeActsInfo() {
        List<String> parameters = getParameters();

        // Tree configuration
        String actsInfo = "----- Tree Configuration ---" + LINE_SEPARATOR + "[Parameter]" + LINE_SEPARATOR;
        for (String parameter : parameters) {
            actsInfo += setParameter(parameter, MODE_ACTS);
        }

        // Constraints configuration
        makeConstraintList(MODE_ACTS);
        actsInfo += "----- constraints ---" + LINE_SEPARATOR + "[Constraint]" + LINE_SEPARATOR;
        for (String constraint : addNewConstraintList) {
            actsInfo += constraint + LINE_SEPARATOR;
        }
        return actsInfo;
    }

    /**
     * Gets the parameters of the parent node of the leaf node.
     * @return Parameters of the parent node of the leaf node.
     */
    private List<String> getParameters() {
        List<String> parameters = new ArrayList<String>();
        for (String leaf : leafList) {
            String parent = parentIdMap.get(leaf);

            if (!parameters.contains(parent)) {
                parameters.add(parent);
            }
        }
        return parameters;
    }

    /**
     * Get the ACTS parameter and the corresponding value.
     * @param parameter ACTS parameter
     * @param mode ACTS mode
     * @return parameter and corresponding value
     */
    private String setParameter(String parameter, int mode) {
        String info = "";
        if (mode == MODE_ACTS) {
            info = parameter + "(enum) : ";
        }
        boolean init = true;
        for (String leaf : leafList) {
            String parent = parentIdMap.get(leaf);
            if (parameter.equals(parent)) {
                if (init) {
                    info += leaf;
                    init = false;
                } else {
                    info += ", " + leaf;
                }
            }
        }
        info += LINE_SEPARATOR;
        return info;
    }

    /**
     * <pre>
     * Converts the representation of formulas and leaf nodes.
     *  "NotEqual" → "!="
     *  "AND" → "&&"
     *  "OR" → "||"
     * 
     * ACTSのインプット向けに論理式およびリーフノードの表現を変換する NotEqual → != , AND → &&, OR → ||
     * </pre>
     * 
     * @param logicalExpression Logical formula before conversion
     * @param leaf Leaf node
     * @return Logical formula after conversion
     */
    private String replaceFormula(String logicalExpression, String leaf) {
        if (logicalExpression.indexOf("!" + leaf) != -1) {
            logicalExpression = logicalExpression.replaceAll("!" + leaf, convertFormulaNotForActs(leaf));
        } else {
            logicalExpression = logicalExpression.replaceAll(leaf, convertFormulaForActs(leaf));
        }
        logicalExpression = logicalExpression.replaceAll("AND", "&&");
        logicalExpression = logicalExpression.replaceAll("OR", "||");

        return logicalExpression;
    }

    /**
     * <pre>
     * Convert the copied TCNode ID map to the original TCNode ID map.
     * 
     * CopyしたTCNodeのIDマップをオリジナルTCNodeのIDマップに変換する
     * </pre>
     * 
     * @param copier
     * @param flatteningResult The result of the flattening process.
     */
    private void convertIdMap(Copier copier, TSDFlatteningResult flatteningResult) {
        Map<String, TCNode> idMap = flatteningResult.getIdMap(); // CopyしたTCNodeで作られたIDマップ
        Map<String, TCNode> replaceMap = new HashMap<String, TCNode>(); // 置き換えたIDマップ

        for (Entry<String, TCNode> entry : idMap.entrySet()) {
            String id = entry.getKey();
            TCNode copyNode = entry.getValue();
            TCNode tcNode = null;
            for (Map.Entry<EObject, EObject> copyEntry : copier.entrySet()) {
                if (copyEntry.getValue().equals(copyNode)) { // KeyがオリジナルTCNode、ValueがCopyしたTCNode
                    tcNode = (TCNode) copyEntry.getKey();
                }
            }
            if (null != tcNode) {
                replaceMap.put(id, tcNode);
            }
        }
        flatteningResult.setIdMap(replaceMap);
    }
}
